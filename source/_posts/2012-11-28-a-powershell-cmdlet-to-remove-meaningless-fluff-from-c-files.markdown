---
layout: post
title: A Powershell cmdlet to remove meaningless fluff from C# files
date: 2012-11-28 23:01
comments: false
external-url:
categories: [powershell,regex,style] 
---

In C# you can add folding points to the code file by using the `#region` directive. The question of [how and when](http://stackoverflow.com/questions/755465/do-you-say-no-to-c-sharp-regions) ([if ever](http://www.codinghorror.com/blog/2008/07/the-problem-with-code-folding.html)) to use this feature is an endless debate among C# developers. Some find it useful for grouping members with related functionality or by accessibility level, some just hate them.

<!-- More -->

My personal opinion is that regions are pretty much useless. When I open a file in the editor I expect to see the code. Not a bunch of gray text blocks, which is the default behavior in Visual Studio. Hiding generated code that is never to be touched or non-implemented members from a poorly designed abstract base class with too many responsibilities, are a couple of use cases that I think are justified. A few years ago I found out that you could disable folding/outlining by navigating to _tools > options > text editor > c# > advanced_ and uncheck the _Enter outlining mode when files open_ option. I've left it like that ever since. There is also the [I Hate #Regions](http://visualstudiogallery.msdn.microsoft.com/0ca60d35-1e02-43b7-bf59-ac7deb9afbca) Visual Studio extension that does the same thing, more or less.

## The regionalize everything style

I recently inherited an ASP.NET MVC project where the C# code uses an interesting region pattern. Every member of a class is surrounded by a region, where the region label matches the signature of the member. The regions were generated by a macro together with XML documentation comments for the members. 
	
``` csharp Region wrapped method
#region public int GetSum( int x, int y )
/// <summary>
///
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
public int GetSumEx( int x, int y, bool absolute ) {		
	return absolute ? Math.Abs(x+y) : x+y;
}
#endregion
```

Except for the regions I'm OK with documentation comments. _Good_ documentation comments on the public members of an API is very nice to have since the intellisense picks them up and you can see it inline while coding.

However, in this codebase many comment elements are left empty, adding a lot of meaningless noise to the code. Another annoyance as seen in the somewhat contrived example is that when the method has been refactored, the region label and comments have not been updated.

This kind of region (mis)use is way to obtrusive to me, so I decided to clean it up.

## The cmdlet

What we want to do is remove all regions and empty documentation comments from the C# files of the solution. Sounds like a perfect time for me to learn how to [make a Powershell cmdlet that processes pipeline input](http://blogs.technet.com/b/heyscriptingguy/archive/2011/05/10/use-the-pipeline-to-create-robust-powershell-functions.aspx). The goal is to be able to write something like this:
	
	> ls c:\myproject -r -i *.cs | remove-regions

That is, get all descendant .cs files of a directory and pipe them into the `remove-regions` cmdlet. 

After a little experimenting I ended up with this:

``` powershell Remove-Regions https://github.com/derantell/MyPsUtils/blob/master/Derantell.psm1 derantell.psm1
Function Remove-Regions {
    [CmdletBinding(SupportsShouldProcess=$True)]
    Param(
        [Parameter( Mandatory=$True, ValueFromPipeline=$True, =$True)]
        [string[]] 
        $Filename,

        [string] 
        $Encoding = "UTF8"
    )        
    
    PROCESS {
        $regex = New-Object System.Text.Regularexpressions.Regex(
            "\s*(?:#(?:end)?region|///\s*<([^/\s>]+).*?>(?s:[\s/]*?</\1>)).*")        
        Foreach ($file in $filename) {            
            $filepath = resolve-path $file
            try {                   
                if ($PSCmdlet.ShouldProcess($filepath, "Remove regions")) {
                    $regex.Replace([System.IO.File]::ReadAllText($filepath),"")`
                        | out-file $file -force -encoding $Encoding
                }
            } catch {
                write-warning "Failed to sanitize $filepath: $_"
            } finally {
                write-output $file
            } 
        }
    }
}
```

The `CmdletBinding` attribute [adds some useful capabilities](http://www.windowsitpro.com/blog/powershell-with-a-purpose-blog-36/windows-powershell/powershells-[cmdletbinding]-142114) to the function, e.g. by setting the `SupportsShouldProcess` flag to true we can use the `-WhatIf` and `-Confirm` switches when calling our cmdlet.

In the `Parameter` attribute we specify that `$Filename` is a required parameter that accepts input from the powershell pipeline. The other parameter - `$Encoding` - has the default value _UTF8_ and sets the output encoding used when writing the modified file.

In order to match and replace the offending lines in the file I need to dust off my old regex-fu.

### Decoding the regex

The regular expression looks like this:
	
	\s*(?:#(?:end)?region|///\s*<([^/\s>]+).*?>[\s/]*?</\1>).*

The expression starts off by trying to match `\s*` - zero or more whitespace. It then enters a [non-capturing group](http://www.regular-expressions.info/brackets.html) `(?:` where the first alternative `#(?:end)?region`, tries to match either a `#region` directive or an `#endregion` directive. 

The second alternative should match empty document comment elements. It does this by first matching the triple slash comment `///\s*` used for documentation. 

Next comes the start tag `<([^/\s>]+).*?>`. The tag name is saved in group 1 for future reference and the [character class](http://www.regular-expressions.info/charclass.html) `[^/\s>]+` says "match one or more characters that is not a / (we want to match the _start tag_), a whitespace (not a valid XML-name character) or a > (the tag end.)" Some elements has attributes so we match `.*?>`, i.e. any character after the name up to the next >. 

As we saw in the example earlier, some elements are empty and spanning multiple rows. Therefore, to match the content of an empty element, we use the character class `[\s/]*?`. I.e. zero or more whitespace (including line breaks) or / characters. 

The last thing to match is the end tag of the element, which i done by `</\1>`. Here we use a [back reference](http://www.regular-expressions.info/brackets.html) to the tag name we captured when we matched the start tag of the element.

Lastly we close the grouping that wraps the expression and match the rest of the line `).*`.

The result looks like this in [RegexBuddy](http://www.regexbuddy.com), my weapon of choice when it comes to constructing and testing regexes. 

![Screenshot of RegexBuddy](/images/regionregex.PNG)

Blue and yellow text are matches to the regex. You can [get the code at GitHub](https://github.com/derantell/MyPsUtils) if you face similar problems. 